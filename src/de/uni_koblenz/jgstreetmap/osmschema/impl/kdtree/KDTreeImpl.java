/*
 * This code was generated automatically.
 * Do NOT edit this file, changes will be lost.
 * Instead, change and commit the underlying schema.
 */

package de.uni_koblenz.jgstreetmap.osmschema.impl.kdtree;

import de.uni_koblenz.jgralab.impl.IncidenceIterable;
import de.uni_koblenz.jgralab.impl.VertexImpl;

import de.uni_koblenz.jgralab.AttributedElement;
import de.uni_koblenz.jgralab.Edge;
import de.uni_koblenz.jgralab.EdgeDirection;
import de.uni_koblenz.jgralab.Graph;
import de.uni_koblenz.jgralab.GraphIO;
import de.uni_koblenz.jgralab.GraphIOException;

import de.uni_koblenz.jgstreetmap.osmschema.OsmSchema;
import de.uni_koblenz.jgstreetmap.osmschema.Node;
import de.uni_koblenz.jgstreetmap.osmschema.OsmGraph;
import de.uni_koblenz.jgstreetmap.osmschema.kdtree.NodeSet;
import de.uni_koblenz.jgstreetmap.osmschema.kdtree.YKey;
import de.uni_koblenz.jgstreetmap.osmschema.kdtree.XKey;
import de.uni_koblenz.jgstreetmap.osmschema.kdtree.Key;

import java.io.IOException;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.Set;
import java.util.Collections;

public class KDTreeImpl extends VertexImpl implements de.uni_koblenz.jgralab.Vertex, de.uni_koblenz.jgstreetmap.osmschema.kdtree.KDTree {

	protected int levels;
	private YKey root;
	private int gId;
	private OsmGraph g;

	public KDTreeImpl(int id, OsmGraph g) {
		super(id, g, OsmSchema.instance().vc_kdtree_KDTree);
		this.g=g;
		this.gId=id;
		//construct kdtree out of given graph
		//get all Vertices of the Graph
		LinkedList<Node> nodeList=new LinkedList<Node>();
		for(Node n : g.getNodeVertices()){
			nodeList.add(n);
		}
		
		root=constructkdTreeY(nodeList,1);
	}
	
	public YKey constructkdTreeY(LinkedList<Node> nodeList, int depth){
		Collections.sort(nodeList, new YComparator());
		YKey yk=new YKeyImpl(gId,g);
		//TODO: Plus/Minus 1 für nodeList.size() nochmal kontrollieren
		yk.setKeyValue(nodeList.get(nodeList.size()/2).getLatitude());
		
		if((depth+1==levels)||(nodeList.size()<=1)){//wenn zutreffend bekommt YKey NodeSet als Kind,
			//wobei NodeSet alle Knoten enthält, die in der LinkedList bis
			//hierhin mitgeführt wurden
			NodeSet set=new NodeSetImpl(gId,g);
			set.setNodeSet(nodeList);
			yk.addSet(set);
		}
		else{
			//Teilen der LinkedList
			LinkedList<Node> leftList=new LinkedList<Node>();
			for(int i=0; i<=nodeList.size()/2;i++){
				leftList.add(nodeList.poll());
			}
			
			yk.addChild(constructkdTreeX(leftList,depth+1));
			yk.addChild(constructkdTreeX(nodeList,depth+1));
		}
		return yk;
	}
	
	public XKey constructkdTreeX(LinkedList<Node> nodeList, int depth){
		Collections.sort(nodeList, new XComparator());
		XKey xk=new XKeyImpl(gId,g);
		xk.setKeyValue(nodeList.get(nodeList.size()/2).getLongitude());
		
		if((depth+1==levels)||(nodeList.size()<=1)){//wenn zutreffend bekommt XKey NodeSet als Kind,
			//wobei NodeSet alle Knoten enthält, die in der LinkedList bis
			//hierhin mitgeführt wurden
			NodeSet set=new NodeSetImpl(gId,g);
			set.setNodeSet(nodeList);
			xk.addSet(set);
		}
		else{
			//Teilen der LinkedList
			LinkedList<Node> leftList=new LinkedList<Node>();
			for(int i=0; i<=nodeList.size()/2;i++){
				leftList.add(nodeList.poll());
			}
	
			xk.addChild(constructkdTreeY(leftList,depth+1));
			xk.addChild(constructkdTreeY(nodeList,depth+1));
		}
		return xk;
	}
	
	public LinkedList<Node> rangeQuery(double topLeftLong,double topLeftLat,double bottomRightLong, double bottomRightLat,YKey key){
		LinkedList<Node> includedNodes=new LinkedList<Node>();
		double keyVal=key.getKeyValue();
		if(key.getChildList().size()==0){ //entspricht hat keine XKey-Kinder
			rangeQuery(topLeftLong, topLeftLat,bottomRightLong,bottomRightLat,key.getSetList().get(0));
		}
		else{
			if(keyVal<=bottomRightLat){
				//ges. rechten Teilbaum in includedNodes eintragen
				includedNodes.addAll(traverse(key.getChildList().get(1)));
			}
			if(keyVal>=topLeftLat){
				//ges. linken Teilbaum in includedNodes eintragen
				includedNodes.addAll(traverse(key.getChildList().get(0)));
			}
			if((bottomRightLat<keyVal)&&(keyVal<topLeftLat)){
				//in Baum hinabsteigen
				includedNodes.addAll(rangeQuery(topLeftLong,topLeftLat,bottomRightLong,bottomRightLat,key.getChildList().get(0)));
				includedNodes.addAll(rangeQuery(topLeftLong,topLeftLat,bottomRightLong,bottomRightLat,key.getChildList().get(1)));
			}
		}
		
		return includedNodes;
	}
	
	public LinkedList<Node> rangeQuery(double topLeftLong,double topLeftLat,double bottomRightLong, double bottomRightLat,XKey key){
		LinkedList<Node> includedNodes=new LinkedList<Node>();
		double keyVal=key.getKeyValue();
		
		if(key.getChildList().size()==0){ //entspricht hat keine XKey-Kinder
			rangeQuery(topLeftLong, topLeftLat,bottomRightLong,bottomRightLat,key.getSetList().get(0));
		}
		else{
			if(keyVal<=topLeftLong){
				//ges. rechten Teilbaum in includedNodes eintragen
				includedNodes.addAll(traverse(key.getChildList().get(1)));
			}
			if(keyVal>=bottomRightLong){
				//ges. linken Teilbaum in includedNodes eintragen
				includedNodes.addAll(traverse(key.getChildList().get(0)));
			}
			if((topLeftLong<keyVal)&&(keyVal<bottomRightLong)){
				//in Baum hinabsteigen
				includedNodes.addAll(rangeQuery(topLeftLong,topLeftLat,bottomRightLong,bottomRightLat,key.getChildList().get(0)));
				includedNodes.addAll(rangeQuery(topLeftLong,topLeftLat,bottomRightLong,bottomRightLat,key.getChildList().get(1)));
			}
		}
		
		return includedNodes;
	}
	
	public LinkedList<Node> rangeQuery(double topLeftLong,double topLeftLat,double bottomRightLong, double bottomRightLat,NodeSet set){
		LinkedList<Node> nodes=set.getNodeSet();
		LinkedList<Node> includedNodes=new LinkedList<Node>();
		
		for(int i=0;i<nodes.size();i++){
			if((nodes.get(i).getLatitude()<=topLeftLat)&&(nodes.get(i).getLatitude()>=bottomRightLat))
					if((nodes.get(i).getLongitude()<=bottomRightLong)&&(nodes.get(i).getLongitude()>=topLeftLong))
						includedNodes.add(nodes.get(i));
		}
		
		return includedNodes;
	}
	
	public LinkedList<Node> traverse(XKey k){
		LinkedList<Node> nodes=new LinkedList<Node>();
		
		if(k.getChildList().size()!=0){
			nodes.addAll(traverse(k.getChildList().get(0)));
			nodes.addAll(traverse(k.getChildList().get(1)));
		}
		else{
			nodes.addAll(k.getSetList().get(0).getNodeSet());
		}
		return nodes;
	}
	
	public LinkedList<Node> traverse(YKey k){
		LinkedList<Node> nodes=new LinkedList<Node>();
		
		if(k.getChildList().size()!=0){
			nodes.addAll(traverse(k.getChildList().get(0)));
			nodes.addAll(traverse(k.getChildList().get(1)));
		}
		else{
			nodes.addAll(k.getSetList().get(0).getNodeSet());
		}
		return nodes;
	}

	public java.lang.Class<? extends AttributedElement> getM1Class() {
		return de.uni_koblenz.jgstreetmap.osmschema.kdtree.KDTree.class;
	}

	public Object getAttribute(String attributeName) throws NoSuchFieldException {
		if (attributeName.equals("levels")) return levels;
		throw new NoSuchFieldException("kdtree.KDTree doesn't contain an attribute " + attributeName);
	}

	@SuppressWarnings("unchecked")
	public void setAttribute(String attributeName, Object data) throws NoSuchFieldException {
		if (attributeName.equals("levels")) {
			setLevels((Integer) data);
			return;
		}
		throw new NoSuchFieldException("kdtree.KDTree doesn't contain an attribute " + attributeName);
	}

	public int getLevels() {
		return levels;
	}

	public void setLevels(int levels) {
		this.levels = levels;
		graphModified();
	}

	public void readAttributeValues(GraphIO io) throws GraphIOException {
		levels = io.matchInteger();
		setLevels(levels);
	}

	public void writeAttributeValues(GraphIO io) throws GraphIOException, IOException {
		io.space();
		io.writeInteger(levels);
	}

	/* add all valid from edges */
	private static Set<java.lang.Class<? extends Edge>> validFromEdges = new HashSet<java.lang.Class<? extends Edge>>();
	
	/* (non-Javadoc)
	 * @see jgralab.Vertex:isValidAlpha()
	 */
	public boolean isValidAlpha(Edge edge) {
		return validFromEdges.contains(edge.getClass());
	}
	
	//anonymer Konstruktor, d.h. der Konstruktor wird immer vor jedem anderen Konstruktor ausgef�hrt
	{

		validFromEdges.add(de.uni_koblenz.jgstreetmap.osmschema.impl.kdtree.HasRootImpl.class);

	}
	
	/* add all valid to edges */
	private static Set<java.lang.Class<? extends Edge>> validToEdges = new HashSet<java.lang.Class<? extends Edge>>();
	
	/* (non-Javadoc)
	 * @see jgralab.Vertex:isValidOemga()
	 */
	public boolean isValidOmega(Edge edge) {
		return validToEdges.contains(edge.getClass());
	}
	
	{

	}

	public de.uni_koblenz.jgstreetmap.osmschema.kdtree.KDTree getNextKDTree() {
		return (de.uni_koblenz.jgstreetmap.osmschema.kdtree.KDTree)getNextVertexOfClass(de.uni_koblenz.jgstreetmap.osmschema.kdtree.KDTree.class);
	}

	public de.uni_koblenz.jgstreetmap.osmschema.kdtree.HasRoot getFirstHasRoot() {
		return (de.uni_koblenz.jgstreetmap.osmschema.kdtree.HasRoot)getFirstEdgeOfClass(de.uni_koblenz.jgstreetmap.osmschema.kdtree.HasRoot.class);
	}

	public de.uni_koblenz.jgstreetmap.osmschema.kdtree.HasRoot getFirstHasRoot(EdgeDirection orientation) {
		return (de.uni_koblenz.jgstreetmap.osmschema.kdtree.HasRoot)getFirstEdgeOfClass(de.uni_koblenz.jgstreetmap.osmschema.kdtree.HasRoot.class, orientation);
	}
	

	private static java.util.HashSet<Class<? extends Edge>> connectedRootEdgeSet = new java.util.HashSet<Class<? extends Edge>>();
	{
		connectedRootEdgeSet.add(de.uni_koblenz.jgstreetmap.osmschema.kdtree.HasRoot.class);
	}

	public java.util.List<? extends de.uni_koblenz.jgstreetmap.osmschema.kdtree.Key> getRootList() {
		java.util.List<de.uni_koblenz.jgstreetmap.osmschema.kdtree.Key> list = new java.util.ArrayList<de.uni_koblenz.jgstreetmap.osmschema.kdtree.Key>();
		de.uni_koblenz.jgstreetmap.osmschema.kdtree.HasRoot edge = getFirstHasRoot(EdgeDirection.OUT);
		while (edge != null) {
			if (connectedRootEdgeSet.contains(edge.getM1Class())) {
				list.add((de.uni_koblenz.jgstreetmap.osmschema.kdtree.Key)edge.getThat());
			}
			edge = edge.getNextHasRoot(EdgeDirection.OUT);
		}
		return list;
	}

	public de.uni_koblenz.jgstreetmap.osmschema.kdtree.HasRoot addRoot(de.uni_koblenz.jgstreetmap.osmschema.kdtree.Key vertex) {
		return ((de.uni_koblenz.jgstreetmap.osmschema.OsmGraph)getGraph()).createHasRoot(this, vertex);
	}

	public void removeRoot(de.uni_koblenz.jgstreetmap.osmschema.kdtree.Key vertex) {
	    Edge e = getFirstHasRoot();
	    while (e != null && e.getThat() == vertex) {
	        e.delete();
	        e = getFirstHasRoot();
	    }
	    while (e != null) {
	        Edge f = e.getNextEdge();
	        while (f != null && f.getThat() == vertex) {
	           f.delete();
	           f = e.getNextEdge();
	        }
	        e = f;
	   }
	}

	public Iterable<de.uni_koblenz.jgstreetmap.osmschema.kdtree.HasRoot> getHasRootIncidences() {
		return new IncidenceIterable<de.uni_koblenz.jgstreetmap.osmschema.kdtree.HasRoot>(this, de.uni_koblenz.jgstreetmap.osmschema.kdtree.HasRoot.class);
	}
	
	
	public Iterable<de.uni_koblenz.jgstreetmap.osmschema.kdtree.HasRoot> getHasRootIncidences(EdgeDirection direction) {
		return new IncidenceIterable<de.uni_koblenz.jgstreetmap.osmschema.kdtree.HasRoot>(this, de.uni_koblenz.jgstreetmap.osmschema.kdtree.HasRoot.class, direction);
	}

}
